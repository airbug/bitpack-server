//-------------------------------------------------------------------------------
// Indexes
//-------------------------------------------------------------------------------


// EmailToUserId
//-------------------------------------------------------------------------------

path /indexes/emailToUserId/{email}  {
    read() {
        isCurrentUserId(this) || isCurrentUserAdmin() || this == null
    }
    write() {
        (
            doesNotExist(this) || isCurrentUserId(prior(this))
        ) && (
            isCurrentUserId(this) || willNotExist(this)
        ) || (
            isCurrentUserAdmin()
        )
    }
    validate() {
        isEmailString(unescapePathPart(email)) && isExistingUserId(this) && willBeUsersEmail(this.parent().parent().parent(), this, unescapePathPart(email))
    }
}

function emailDoesNotExist(email) {
    return root.indexes.emailToUserId[escapePathPart(prior(email))] == null;
}

function willBeIndexedEmailForUserId(newRoot, email, userId) {
    return newRoot.indexes.emailToUserId[escapePathPart(email)] == userId;
}


// UsernameToUserId
//-------------------------------------------------------------------------------

path /indexes/usernameToUserId {
    read() { true }
}

path /indexes/usernameToUserId/{username}  {
    write() {
        (
            doesNotExist(this) || isCurrentUserId(prior(this))
        ) && (
            isCurrentUserId(this) || willNotExist(this)
        ) || (
            isCurrentUserAdmin()
        )
    }
    validate() {
        isUsername(username) && isExistingUserId(this) && willBeUsersUsername(this.parent().parent().parent(), this, username)
    }
}

function usernameDoesNotExist(username) {
    return root.indexes.usernameToUserId[prior(username)] == null;
}

function willBeIndexedUsernameForUserId(newRoot, username, userId) {
    return newRoot.indexes.usernameToUserId[username] == userId;
}


//-------------------------------------------------------------------------------
// PublishKey
//-------------------------------------------------------------------------------

path /publishKey/ {
    read() { false }
}

path /publishKey/{publishKey} is PublishKey {
    write() {
        doesNotExist(this) &&
        !isRecipeVersionPublished(this.recipeType, this.recipeScope, this.recipeName, this.recipeVersionNumber) &&
        isCurrentUserRecipeCollaborator(this.recipeName)
    }
    validate() { isKey(publishKey) }
}

path /publishKey/{publishKey}/key {
    validate() { this == publishKey }
}

type PublishKey extends TimeStamped {
    key: Key,
    recipeHash: RecipeHash,
    recipeName: RecipeName,
    recipeScope: RecipeScope,
    recipeType: RecipeType,
    recipeVersionNumber: RecipeVersionNumber,
    usedAt: Number | Null
}

type Key extends String {
    validate() { isKey(this) }
}

function isKey(value) {
    return value.test(/^[0-9a-f]{80}$/);
}


//-------------------------------------------------------------------------------
// Recipes
//-------------------------------------------------------------------------------

path /recipes/{recipeType}/ {
    validate() { recipeType == 'gulp' }
}

path /recipes/{recipeType}/{recipeScope}/ {
    read() { true }
    validate() { recipeScope == 'public' }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/info is Recipe {
    write() {
        doesNotExist(this) ||
        isCurrentUserRecipeOwner(recipeName) ||
        isCurrentUserAdmin()
    }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/info/scope {
    validate() { this == recipeScope }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/info/name {
    validate() { this == recipeName }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/info/type {
    validate() { this == recipeType }
}

type Recipe extends TimeStamped {
    name: RecipeName,
    scope: RecipeScope,
    type: RecipeType
}

type RecipeName extends String {
    validate() { isRecipeName(this) }
}

type RecipeScope extends String {
    validate() { isRecipeScope(this) }
}

type RecipeType extends String {
    validate() { isRecipeType(this) }
}

function isRecipeName(value) {
    return value.test(/^[a-z]+(?:[a-z0-9-][a-z0-9]+)*$/);
}

function isRecipeScope(value) {
    return value == 'public';
}

function isRecipeType(value) {
    return value == 'gulp';
}


//-------------------------------------------------------------------------------
// RecipeCollaborators
//-------------------------------------------------------------------------------

path /recipes/{recipeType}/{recipeScope}/{recipeName}/collaborators {
    write() {
        doesNotExist(this) ||
        isCurrentUserRecipeOwner(recipeName) ||
        isCurrentUserAdmin()
    }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/collaborators/{userId} is RecipeCollaborator {
    validate() { isExistingUserId(userId) }
    write() {
        isCurrentUserId(userId) && willNotExist(this)
    }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/collaborators/{userId}/userId {
    validate() { this == userId }
}

type RecipeCollaborator extends TimeStamped {
    owner: Boolean,
    userId: ExistingUserId
}

function isCurrentUserRecipeCollaborator(recipeType, recipeScope, recipeName) {
    return isUserRecipeCollaborator(recipeType, recipeScope, recipeName, auth.uid);
}

function isCurrentUserRecipeOwner(recipeName) {
    return isUserRecipeOwner(recipeType, recipeScope, recipeName, auth.uid);
}

function isUserRecipeCollaborator(recipeType, recipeScope, recipeName, userId) {
    return root.recipes[recipeType][recipeScope][recipeName].collaborators[userId] !== null;
}

function isUserRecipeOwner(recipeType, recipeScope, recipeName, userId) {
    return root.recipes[recipeType][recipeScope][recipeName].collaborators[userId].owner === true;
}


//-------------------------------------------------------------------------------
// RecipeVersionsInfo
//-------------------------------------------------------------------------------

path /recipes/{recipeType}/{recipeScope}/{recipeName}/versionsInfo is RecipeVersionsInfo {
    write() { isCurrentUserRecipeCollaborator(recipeType, recipeScope, recipeName) }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/versionsInfo/last {
    validate() {
        isExistingRecipeVersionNumber(recipeType, recipeScope, recipeName, this) || (
            doesNotExist(this.parent()) && this == ''
        )
    }
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/versionsInfo/all/{versionNumber} is RecipeVersionNumber {
    validate() {
        this == unescapePathPart(versionNumber) &&
        willRecipeVersionExist(
            this.parent().parent().parent().parent().parent().parent().parent(),
            recipeType,
            recipeScope,
            recipeName,
            unescapePathPart(versionNumber))
    }
}

type RecipeVersionsInfo extends TimeStamped {
    last: RecipeVersionNumber
}

function willRecipeVersionInfoExist(newRoot, recipeType, recipeScope, recipeName, recipeVersionNumber) {
    return newRoot.recipes[recipeType][recipeScope][recipeName].versionsInfo.all[escapePathPart(recipeVersionNumber)] != null;
}


//-------------------------------------------------------------------------------
// RecipeVersions
//-------------------------------------------------------------------------------

path /recipes/{recipeType}/{recipeScope}/{recipeName}/versions/{versionNumber} is RecipeVersion {
    validate() {
        isRecipeVersionNumber(unescapePathPart(versionNumber)) &&
        willRecipeVersionInfoExist(
            this.parent().parent().parent().parent().parent().parent(),
            recipeType,
            recipeScope,
            recipeName,
            unescapePathPart(versionNumber))
    }
    write() {
        (
            doesNotExist(this) && isCurrentUserRecipeCollaborator(recipeType, recipeScope, this)
        ) || (
            isCurrentUserRecipeOwner(this)
        ) || (
            isCurrentUserAdmin()
        )
    }
}

type RecipeVersion extends TimeStamped {
    hash: RecipeHash,
    published: Boolean,
    semanticVersion: SemanticVersion,
    url: String,
    versionNumber: RecipeVersionNumber
}

path /recipes/{recipeType}/{recipeScope}/{recipeName}/versions/{versionNumber}/versionNumber {
    validate() { this == unescapePathPart(versionNumber) }
}

type RecipeHash extends String {
    validate() { isRecipeHash(this) }
}

type RecipeVersionNumber extends String {
    validate() { isRecipeVersionNumber(this) }
}

type SemanticVersion {
    build: Array<BuildString>,
    major: NonNegativeInteger,
    minor: NonNegativeInteger,
    patch: NonNegativeInteger,
    prerelease: Array<PrereleaseString>,
    raw: SemanticVersionString,
    version: VersionString
}

type BuildString extends String {
    validate() { isBuildString(this) }
}

type PrereleaseString extends String {
    validate() { isPrereleaseString(this) }
}

type SemanticVersionString extends String {
    validate() { isSemanticVersionString(this) }
}

type VersionString extends String {
    validate() { isVersionString(this) }
}

function isBuildString(value) {
    return value.test(/^([0-9A-Za-z-][0-9A-Za-z-]*)$/);
}

function isExistingRecipeVersionNumber(recipeType, recipeScope, recipeName, value) {
    return isRecipeVersionNumber(value) && root.recipes[recipeType][recipeScope][recipeName].versions[escapePathPart(value)] != null;
}

function isPrereleaseString(value) {
    return value.test(/^([0-9]|([1-9A-Za-z-][0-9A-Za-z-]*))$/);
}

function isRecipeHash(value) {
    //TODO BRN:
    return value.length > 32;
}

function isRecipeVersionNumber(value) {
    return isVersionString(value);
}

function isRecipeVersionPublished(recipeType, recipeScope, recipeName, recipeVersionNumber) {
    return root.recipes[recipeType][recipeScope][recipeName].versions[recipeVersionNumber].published === true;
}

function isSemanticVersionString(value) {
    return value.test(/^[0-9]\.[0-9]\.[0-9](-([0-9]|([1-9A-Za-z-][0-9A-Za-z-]*))(\.([0-9]|([1-9A-Za-z-][0-9A-Za-z-]*)))*)?(\+([0-9A-Za-z-][0-9A-Za-z-]*)(\.([0-9A-Za-z-][0-9A-Za-z-]*))*)?$/);
}

function isVersionString(value) {
    return value.test(/^[0-9]\.[0-9]\.[0-9](-([0-9]|([1-9A-Za-z-][0-9A-Za-z-]*))(\.([0-9]|([1-9A-Za-z-][0-9A-Za-z-]*)))*)?$/);
}

function willRecipeVersionExist(newRoot, recipeType, recipeScope, recipeName, recipeVersionNumber) {
    return newRoot.recipes[recipeType][recipeScope][recipeName].versions[escapePathPart(recipeVersionNumber)] != null;
}


//-------------------------------------------------------------------------------
// Roles
//-------------------------------------------------------------------------------

path /roles/{userId} is Role {
    read() { isCurrentUserId(userId) || isCurrentUserAdmin() }
    write() { isCurrentUserAdmin() }
    validate() { isExistingUserId(userId) }
}

type Role extends Entity {
    role: RoleString | EmptyString,
    userId: ExistingUserId
}

type RoleString extends String {
    validate() { this == 'admin' }
}

function isCurrentUserAdmin() {
    return root.roles[auth.uid].role == 'admin';
}


//-------------------------------------------------------------------------------
// Users
//-------------------------------------------------------------------------------

path /users/{userId} is User | EmptyPush {
    read() { isCurrentUserId(userId) || isCurrentUserAdmin() }
    write() { isCurrentUserId(userId) || isCurrentUserAdmin() }
}

path /users/{userId}/email  {
    validate() {
        isEmptyString(this) || (
            isEmailString(this) && emailDoesNotExist(this) && willBeIndexedEmailForUserId(this.parent().parent().parent(), this, userId)
        )
    }
}

path /users/{userId}/username {
    validate() {
        isEmptyString(this) || (
            isUsername(this) && usernameDoesNotExist(this) && willBeIndexedUsernameForUserId(this.parent().parent().parent(), this, userId)
        );
    }
}

type User extends Entity  {
    email: String,
    signedUp: Boolean,
    username: String
}

type EmailString extends String {
    validate() { isEmailString(this) }
}

type UserId extends Id {
    validate() { isUserId(this) }
}

type ExistingUserId extends String {
    validate() { isExistingUserId(this) }
}

type Username extends String {
    validate() { isUsername(this) }
}

type ExistingUsername extends String {
    validate() { isExistingUsername(this) }
}

function isCurrentUserId(userId) {
    return auth.uid === userId;
}

function hasUserId(object) {
    return object.userId !== null;
}

function isAuthenticated() {
    return auth != null;
}

function isEmailString(value) {
    return value.isString() && value.length <= 254 && value.test(/^[-!#$%&'*+\/0-9=?A-Z^_a-z{|}~](\.?[-!#$%&'*+\/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-?\.?[a-zA-Z0-9])*(\.[a-zA-Z](-?[a-zA-Z0-9])*)+$/);
}

function isExistingUserId(value) {
    return isUserId(value) && root.users[value] != null;
}

function isExistingUsername(value) {
    return isUsername(value) && root.indexes.usernameToUserId[value] != null;
}

function isUserId(value) {
    return isId(value);
}

function isUsername(value) {
    return value.test(/^[a-z]+(?:[a-z0-9-][a-z0-9]+)*$/);
}

function doesCurrentUserOwnObject(object) {
    return isCurrentUserId(prior(object).userId);
}

function isOwnedByOrDoesNotExistAndWillBeOwnedByCurrentUser(object) {
    return (
        doesCurrentUserOwnObject(object) || doesNotExist(object)
    ) && (
        willCurrentUserOwnObject(object)
    );
}

function willBeUsersEmail(newRoot, userId, email) {
  return newRoot.users[userId].email == email;
}

function willBeUsersUsername(newRoot, userId, username) {
  return newRoot.users[userId].username == username;
}

function willCurrentUserOwnObject(object) {
    return isCurrentUserId(object.userId);
}


//-------------------------------------------------------------------------------
// Util
//-------------------------------------------------------------------------------

type Array<T> {
    $index: ArrayIndex<T>
}

type ArrayIndex<T> extends T {
    validate() { isNumberString($index) }
}

type Entity extends TimeStamped {
    id: Id
}

type TimeStamped {
    createdAt: Number,
    updatedAt: Number
}

type EmptyPush {
    validate() { isEmptyPush(this) }
}

type EmptyString extends String {
    validate() { isEmptyString(this) }
}

type Id extends String {
    validate() { isId(this) }
}

type Integer extends Number {
    validate() { isInteger(this) }
}

type NonNegativeInteger extends Integer {
    validate() { isNonNegative(this) }
}

type NonNegativeNumber extends Number {
    validate() { isNonNegative(this) }
}

function doesExist(value) {
    return prior(value) != null;
}

function doesNotExist(value) {
    return prior(value) == null;
}

function escapePathPart(pathPart) {
    return pathPart
        .replace('.', '(P)')
        .replace('@', '(A)')
        .replace('!', '(B)')
        .replace('#', '(H)')
        .replace('$', '(D)')
        .replace('%', '(PR)')
        .replace('&', '(AN)')
        .replace('\'', '(SQ)')
        .replace('*', '(ST)')
        .replace('+', '(PL)')
        .replace('/', '(FS)')
        .replace('=', '(E)')
        .replace('?', '(Q)')
        .replace('^', '(C)')
        .replace('`', '(G)') //grave accent
        .replace('{', '(OC)')
        .replace('|', '(PI)')
        .replace('}', '(CC)');
}

function isEmptyPush(value) {
    return doesNotExistAndWillNotExist(value);
}

function isEmptyString(value) {
    return value == "";
}

function isId(value) {
    return value.test(/^-[a-zA-Z0-9_-]+$/);
}

function isInteger(value) {
    return value % 1 == 0;
}

function isNonNegative(value) {
    return value >= 0;
}

function isNumberString(value) {
    return value.test(/^[0-9]+$/);
}

function doesNotExistAndWillNotExist(value) {
    return (doesNotExist(value) && willNotExist(value));
}

function unescapePathPart(pathPart) {
    return pathPart
        .replace('(P)', '.')
        .replace('(A)', '@')
        .replace('(B)', '!')
        .replace('(H)', '#')
        .replace('(D)', '$')
        .replace('(PR)', '%')
        .replace('(AN)', '&')
        .replace('(SQ)', '\'')
        .replace('(ST)', '*')
        .replace('(PL)', '+')
        .replace('(FS)' ,'/')
        .replace('(E)', '=')
        .replace('(Q)', '?')
        .replace('(C)', '^')
        .replace('(G)', '`') //grave accent
        .replace('(OC)', '{')
        .replace('(PI)', '|')
        .replace('(CC)', '}')
}

function willExist(value) {
    return value != null;
}

function willNotExist(value) {
    return value == null;
}
